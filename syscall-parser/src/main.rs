use std::io::Write;

#[derive(Debug)]
struct CallbackType {
    name: String,
    arguments: Vec<Argument>,
}

#[derive(Debug, Clone)]
struct Argument {
    name: String,
    ty: Type,
}

impl Argument {
    fn set_pc_type(&self) -> Self {
        let Self { name, ty } = self.clone();

        if name == "pc"
            && matches!(
                &ty,
                Type::Ident(ident)
                    if matches!(ident.as_str(), "target_ulong" | "target_ptr_t")
            )
        {
            Self {
                name: "pc".into(),
                ty: Type::Ident("SyscallPc".into()),
            }
        } else {
            Self { name, ty }
        }
    }
}

#[derive(Debug, Clone)]
enum Type {
    Ptr(Box<Type>),
    Ident(String),
}

impl Type {
    fn as_rust_type(&self) -> String {
        match self {
            Self::Ptr(ptr) => format!("&mut {}", ptr.as_rust_type()),
            Self::Ident(ident) => match &**ident {
                "uint8_t" => "u8",
                "uint16_t" => "u16",
                "uint32_t" => "u32",
                "uint64_t" => "u64",
                "int8_t" => "i8",
                "int16_t" => "i16",
                "int32_t" => "i32",
                "int64_t" => "i64",
                ident @ ("CPUState" | "target_ulong" | "SyscallPc") => ident,
                ident => panic!("type {} unrecognized", ident),
            }
            .into(),
        }
    }
}

fn sanitize_name(name: &str) -> String {
    match name {
        "type" => "_type".into(),
        _ => name.into(),
    }
}

fn syscall_name(callback_name: &str) -> &str {
    let cb_name = callback_name.strip_prefix("on_sys_").unwrap();

    cb_name
        .strip_suffix("_return")
        .unwrap_or_else(|| cb_name.strip_suffix("_enter").unwrap())
}

fn before_or_after(callback_name: &str) -> &'static str {
    if callback_name.ends_with("_return") {
        "after"
    } else if callback_name.ends_with("_enter") {
        "before"
    } else {
        panic!(
            "Callback {} does not end in `return` or `enter`",
            callback_name
        )
    }
}

peg::parser! {
    grammar c_parser() for str {
        pub(crate) rule callback_types() -> Vec<CallbackType>
            = (_? comment())* cb_types:callback_type() ** (_? ";" _?) ";" _ (comment() _?)* {
                cb_types
            }

        rule comment()
            = "//" [^ '\n']* "\n"

        rule callback_type() -> CallbackType
            = "PPP_CB_TYPEDEF" _? "(" _? "void" _? "," _? name:ident() _? ","
                _? arguments:argument() ** ("," _?) _? ")"
            {
                CallbackType { name, arguments }
            }

        // XXX: leftover from typedef version
        //rule callback_type() -> CallbackType
        //    = "typedef" _ "void" _ "(" _? "*" _? name:ident() _? ")" _?
        //      "(" _? arguments:argument() ** ("," _?) _? ")"
        //    {
        //        CallbackType { name, arguments }
        //    }

        rule argument() -> Argument
            = ty:c_type() _ name:ident() { Argument { name, ty } }

        rule c_type() -> Type
            = ptr()
            / type_ident()

        rule ptr() -> Type
            = ident:type_ident() _? "*" { Type::Ptr(Box::new(ident)) }

        rule type_ident() -> Type
            = ident:ident() { Type::Ident(ident) }

        rule ident() -> String
            = ident:$(
                ['a'..='z' | 'A'..='Z' | '_'] ['a'..='z' | 'A'..='Z' | '_' | '0'..='9']*
            ) { ident.into() }

        rule _() = quiet!{ [' ' | '\n' | '\t']+ }
    }
}

const ARCHES: &[(&str, &str)] = &[
    ("x86_64", "x64"),
    ("i386", "x86"),
    ("arm", "arm"),
    ("aarch64", "arm64"),
    // no ppc support
    //("ppc", "ppc"),
    ("mips", "mips"),
    ("mipsel", "mips"),
    ("mips64", "mips"),
];

fn main() {
    let mut decl_file = std::fs::File::create("../panda-rs/src/on_sys.rs").unwrap();
    writeln!(
        decl_file,
        "// AUTOGENERATED BY panda-rs/syscall-parser DO NOT EDIT\n"
    )
    .unwrap();
    for (arch, syscalls_arch) in ARCHES {
        println!("Generating for {}...", arch);

        writeln!(
            decl_file,
            "#[doc(inline)]\n#[cfg(feature = \"{arch}\")]\npub use crate::cbs::{{",
            arch = arch
        )
        .unwrap();

        let path =
            std::path::Path::new(&std::env::var("PANDA_ROOT").expect("Please set 'PANDA_ROOT'"))
                .join(&format!(
                    "panda/plugins/syscalls2/generated/syscalls_ext_typedefs_{}.h",
                    syscalls_arch
                ));

        let contents = std::fs::read_to_string(path).unwrap();
        let mut f =
            std::fs::File::create(format!("../panda-macros/src/syscalls/{}.rs", arch)).unwrap();
        let callback_types = c_parser::callback_types(&contents).unwrap();

        writeln!(f, "// AUTOGENERATED BY panda-rs/syscall-parser DO NOT EDIT").unwrap();
        writeln!(f, "define_syscalls_callbacks! {{").unwrap();
        for callback_type in callback_types {
            let name = callback_type.name.trim_end_matches("_t");

            // omit BSD syscalls
            if name.starts_with("on_sys_") {
                let args = callback_type
                    .arguments
                    .iter()
                    .map(Argument::set_pc_type)
                    .map(|arg| format!("{}: {}", sanitize_name(&arg.name), arg.ty.as_rust_type()))
                    .collect::<Vec<String>>()
                    .join(", ");
                writeln!(
                    f,
                    "    ({name}, add_callback_{name}, {sys_name}, {before_or_after:?}, ({args})),",
                    name = name,
                    sys_name = syscall_name(name),
                    before_or_after = before_or_after(name),
                    args = args,
                )
                .unwrap();

                writeln!(
                    decl_file,
                    "    {} as {},",
                    name,
                    name.strip_prefix("on_sys_").unwrap()
                )
                .unwrap();
            }
        }

        writeln!(f, "}}").unwrap();
        writeln!(decl_file, "}};").unwrap();
    }
}
